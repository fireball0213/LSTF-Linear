# 作业 1

作业1涉及开发一个全面的时间序列分析框架，包括数据集处理、数据转换、指标计算和预测模型等各个组件。

## 使用示例

```
python main.py --data_path ./dataset/ETT/ETTh1.csv --dataset ETT --target OT --model MeanForecast
```

```
python main.py --data_path ./dataset/ETT/ETTh1.csv --dataset ETT --target OT --model TsfKNN --n_neighbors 1 --msas MIMO --distance euclidean
```

## 第1部分：数据集（30分）

路径：`src/dataset/dataset.py`，`src/dataset/data_visualizer.py`

所有数据集可以在[这里](https://box.nju.edu.cn/d/b33a9f73813048b8b00f/)找到。

**目标：** 在这一部分中，你将实现一个自定义数据集类 `CustomDataset`，来处理各种时间序列数据集。你的自定义数据集类将继承自基类 `DatasetBase`，并提供读取和预处理数据的功能。此任务旨在增强你对机器学习和时间序列分析中数据集处理的理解。

**说明：**

**1. CustomDataset 类：**

- 你的任务是实现 `CustomDataset` 类，这是 `DatasetBase` 的一个子类，专门用于处理各种时间序列数据集。

- 在 `CustomDataset` 类中实现 `read_data` 方法：
  - 它应该通过提供一个通用机制来读取和预处理数据来处理不同的数据集格式（CSV文件）。
  - 注意数据集的格式和结构可能会有所不同，所以确保你的实现足够灵活。

- 在 `CustomDataset` 类中实现 `split_data` 方法：
  - 根据 `args` 对象中提供的比例将数据分割成训练集、验证集和测试集。你可以使用基类中的 `ratio_train`、`ratio_val` 和 `ratio_test` 属性。

**2. `data_visualize` 函数：**

- 在 `data_visualizer` 中实现 `data_visualize` 方法。
- 这个函数应该接受两个参数：
  - `dataset`：要可视化的数据集。Dataset.data 的形状可能是 (n_samples, timesteps, channels) 或 (n_samples, timesteps)，这取决于数据集是否有多个通道。
  - `t`：一个整数，表示要可视化的连续时间点的数量。
- 确保你的实现足够灵活，能够处理单通道和多通道数据集。

**3. 测试：**

- 通过创建 `CustomDataset` 类的实例并使用 `get_dataset` 函数加载自定义数据集来测试你的实现。
- 通过访问数据集对象的相关属性（例如 `dataset.train_data`、`dataset.val_data`、`dataset.test_data`）来验证数据是否被正确读取和分割。
- 加载数据集后，调用带有特定 `t` 值的数据集对象上的 `data_visualize` 函数来可视化数据。

**在你的报告中，画出提供的数据集之一，并根据图像简要分析数据集的属性。你可以自由设计你的数据集绘图方式，使图像更美观或更易于分析。**

## 第2部分：转换（20分）

路径：`src/utils/transforms.py`

**目标：** 在这部分中，你将实现各种数据转换技术，用于预处理时间序列数据。这些转换将帮助准备数据以供机器学习模型使用。你将创建继承自 `Transform` 基类并实现必要方法的自定义转换类。

**说明：**

**1. Transform 基类：**

你将获得一个名为 `Transform` 的基类，它定义了数据转换的结构。这个类有两个抽象方法：`transform` 和 `inverse_transform`。你将创建继承自这个基类的自定义转换类，并实现这些方法。

**2. CustomTransform 类：**

- 您需要实现以下自定义转换类，每个类都继承自 `Transform` 基类：

  **a. Normalization 归一化**

  **b. Standardization标准化**

  **c. MeanNormalization均值归一化**

  **d. BoxCox** (input might less than 0)

**在你的报告中，**write down the mathematical formula for each transformation**。**

## 第3部分 指标（20分）

路径：`src/utils/metrics.py`

**目标：** 在这个编程作业中，您将实现几个常用于评估预测模型性能的指标。这些指标将帮助您评估模型所做预测的准确性和质量。您的任务是实现平均绝对误差（MAE）、平均绝对百分比误差（MAPE）、对称平均绝对百分比误差（SMAPE）和平均绝对缩放误差（MASE）指标。

**在您的报告中，写下每个指标的数学公式。**

## 第4部分 模型（30分）

路径：`src/models/baselines.py`

**目标：** 在这部分中，您将设计和实现两个预测模型：线性回归和指数平滑。这些模型将以长度为 `seq_len` 的历史时间序列数据为输入，并生成长度为 `pred_len` 的预测。

**说明：**

**1. MLForecastModel 基类：**

您将获得一个名为 `MLForecastModel` 的基类，它定义了预测模型的结构。该类包括训练（`fit`）和预测（`forecast`）方法。您将创建继承自这个基类的自定义预测模型类，并实现 `_fit` 和 `_forecast` 方法。

**2. 自定义模型：**

**a. LR(MLForecastModel):** 线性回归

**b. ES(MLForecastModel):** 指数平滑

**3. 测试：**

- 在第1部分中您绘制的数据集上测试 `LR` 和 `ES`。
- 加载选定的数据集，将它们划分为训练集和测试集，并应用每个预测模型对测试数据进行预测。
- 计算并记录每个模型和数据集对的相关指标，包括平均绝对误差（MAE）、平均绝对百分比误差（MAPE）、对称平均绝对百分比误差（SMAPE）和平均绝对缩放误差（MASE）。
- 以表格格式呈现评估指标，展示每个模型在每个数据集上的性能。

**在您的报告中，写下每种算法的数学公式，用第1部分中您绘制的数据集对算法进行不同转换的测试，并填写下面的表格。**

| 数据集  | 模型 | 转换    | MSE  | MAE  | MAPE | SMAPE | MASE |
| ------- | ---- | ------- | ---- | ---- | ---- | ----- | ---- |
| dataset | AR   | 无      |      |      |      |       |      |
|         |      | 归一化  |      |      |      |       |      |
|         |      | Box-Cox |      |      |      |       |      |
|         |      | ...     |      |      |      |       |      |
|         | EMA  | 无      |      |      |      |       |      |
|         |      | 归一化  |      |      |      |       |      |
|         |      | Box-Cox |      |      |      |       |      |
|         |      | ...     |      |      |      |       |      |

## 第5部分 TsfKNN*（额外20分）

路径：`src/models/TsfKNN.py`

**目标：** 在这部分中，您将处理基础版的 K-最近邻（KNN）时间序列预测模型（`TsfKNN`）。您的目标是通过实施各种改进来增强和提升模型的性能。最初的模型使用KNN算法，以历史时间序列数据为输入，并使用长度为 `pred_len` 的预测。您将探索两个主要改进领域：增强距离计算和降低计算复杂性。您可以在[这里](https://cran.r-project.org/web/packages/tsfknn/vignettes/tsfknn.html#:~:text=Given a new example%2C KNN,values associated with its nearest)找到这种方法的简单介绍。

**说明：**

**1. 当前实现：**

您将得到 `TsfKNN` 类的基础实现，该类使用KNN算法进行时间序列预测。模型目前支持两种选项：`MIMO` 和 `递归`，用于多步预测。

**2. 距离计算增强：**

**a. 探索不同的距离度量：**

- 目前，模型使用欧几里得距离（`euclidean`）进行KNN。通过允许使用不同的距离度量（如曼哈顿距离、切比雪夫距离或其他）来增强模型。
- 为这些度量实现距离函数，并为用户提供在创建 `TsfKNN` 类的实例时选择所需距离度量的选项。

**b. 实验自定义距离度量：**

- 探索针对时间序列数据特征量身定制的自定义距离度量的使用。自定义距离度量可能会考虑趋势、季节性或循环模式等因素。
- 实现一个或多个自定义距离度量，并允许用户在创建 `TsfKNN` 类的实例时选择它们作为选项。

**3. 计算复杂性降低：**

**a. 近似KNN搜索：**

- 目前的实现使用了精确的KNN搜索，这对于大型数据集可能计算成本很高。研究并实现近似KNN搜索算法，如局部敏感哈希（LSH），以减少计算复杂性，同时保持合理的准确度。
- 提供选项，以便用户在创建 `TsfKNN` 类的实例时启用或禁用近似KNN搜索。

**4. 测试：**

- 在1-2个实际时间序列数据集上测试增强的 `TsfKNN` 模型，如ETT和自定义数据集，以评估其性能。
- 使用评估指标（例如MAE、MAPE、SMAPE、MASE）来衡量模型的准确性，并与模型的基础版本进行比较。
- 比较基础版和增强版在各种操作中所需的计算时间。

**在您的报告中，包括您的算法的详细实现以及在提供的1-2个数据集中时间和准确性的比较。**

## 提交

**1. 修改后的代码：**

- 提供任务所有组件的修改后代码。

- 以Markdown格式包含一个 

  ```
  README.md
  ```

   文件，涵盖整个任务。该文件应包含：

  - 如何安装整个任务所需的任何必要依赖项。
  - 如何运行代码和脚本以重现报告的结果。
  - 在任务的所有部分中用于测试的数据集。

**2. PDF Report:**

- Create a detailed PDF report that encompasses the entire task. The report should include sections for each component of the task.

**3. Submission Format:**

- Submit the entire task, including all code and scripts, along with the `README.md` file and the PDF report, in a compressed archive (.zip).